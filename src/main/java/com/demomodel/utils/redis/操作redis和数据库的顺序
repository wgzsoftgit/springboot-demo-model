https://blog.csdn.net/u011320646/article/details/85491103
(一)缓存和数据库双写一致性问题

(二)缓存雪崩问题

(三)缓存击穿问题

(四)缓存的并发竞争问题

Cache Aside 更新模式  这是最常用的缓存模式了，具体的流程是：

失效：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
命中：应用程序从 cache 中取数据，取到后返回。
更新：先把数据存到数据库中，成功后，再让缓存失效。
http://songwenjie.vip/blog/180511/8AjC2hDbKk.png?imageslim
避坑指南一
先更新数据库，再更新缓存。这种做法最大的问题就是两个并发的写操作导致脏数据。
如下图（以Redis和Mysql为例），两个并发更新操作，数据库先更新的反而后更新缓存，数据库后更新的反而先更新缓存。
这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是脏数据。
http://songwenjie.vip/blog/180511/b8EAiJHeAL.png?imageslim
两个并发的写操作导致脏数据

避坑指南二
先删除缓存，再更新数据库。这个逻辑是错误的，因为两个并发的读和写操作导致脏数据。如下图（以Redis和Mysql为例）。
假设更新操作先删除了缓存，此时正好有一个并发的读操作，没有命中缓存后从数据库中取出老数据并且更新回缓存，
这个时候更新操作也完成了数据库更新。此时，数据库和缓存中的数据不一致，应用程序中读取的都是原来的数据（脏数据）
http://songwenjie.vip/blog/180511/e3A7c3L176.png?imageslim

避坑指南三       先更新数据库，再删除缓存。  推荐
先更新数据库，再删除缓存。这种做法其实不能算是坑，在实际的系统中也推荐使用这种方式。
但是这种方式理论上还是可能存在问题。如下图（以Redis和Mysql为例），查询操作没有命中缓存，
然后查询出数据库的老数据。此时有一个并发的更新操作，更新操作在读操作之后更新了数据库中的数据并且删除了缓存中的数据。
然而读操作将从数据库中读取出的老数据更新回了缓存。这样就会造成数据库和缓存中的数据不一致，应用程序中读取的都是原来的数据（脏数据）。
http://songwenjie.vip/blog/180511/06kCb330cg.png?imageslim

