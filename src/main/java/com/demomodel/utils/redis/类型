String（字符串）、List（列表）、Set（集合）【无序】、Hash（散列）和 Zset（有序集合）。
1、String: 主要用于存储字符串，显然不支持分页和排序。
2、Hash: 主要用于存储key-value型数据，评论模型中全是key-value型数据，所以在这里Hash无疑会用到。
3、List: 主要用于存储一个列表，列表中的每一个元素按元素的插入时的顺序进行保存，如果我们将评论模型按createDate排好序后
再插入List中，似乎就能做到排序了，而且再利用List中的LRANGE key start stop指令还能做到分页。嗯，到这里List似乎
满足了我们分页和排序的要求，但是评论还会被删除，就需要更新Redis中的数据，如果每次删除评论后都将Redis中的数据全部重新写入一次，
显然不够优雅，效率也会大打折扣，如果能删除指定的数据无疑会更好，而List中涉及到删除数据的就只有LPOP和RPOP这两条指令，
但LPOP和RPOP只能删除列表头和列表尾的数据，不能删除指定位置的数据,(备注：其实还有 LREM命令可以做到删除，但是非常不方便)，
而且当存在接口高并发访问时，这个list可能会无限延长，且里面的数据会存在很多重复，这就会影响到正常的业务，所以List也不太适合。

4、Set: 主要存储无序集合，无序！排除。
5、SortedSet: 主要存储有序集合，SortedSet的添加元素指令ZADD key score member [[score,member]…]
会给每个添加的元素member绑定一个用于排序的值score，SortedSet就会根据score值的大小对元素进行排序，在这里就可以
将createDate当作score用于排序，SortedSet中的指令ZREVRANGE key start stop又可以返回指定区间内的成员，
可以用来做分页，SortedSet的指令ZREM key member可以根据key移除指定的成员，能满足删评论的要求，所以，
SortedSet在这里是最适合的（时间复杂度O(log(N))）。

redis分页  
②：基于redis的ZSet数据结构，通过Zset这个有序集合我们也可以做分页，同样也是用range方法，但是这里比较麻烦的是在初始化
数据的时候Zset必须存放TypedTuple类型的数据，这个类型是一个value和score的键值对，具体可以查百度，这个score的生成
比较麻烦我这边测试时用的是当前数据在这个list的位置，然后Zset是根据这个score值来排序的，默认是从小到大；用这个的好处是，
即使在高并发情况下Zset中也不会存在重复数据从而影响正常的业务；而且分页效率也和list结构差不多；

③：用hash和Zset来一起实现；这个是问了一个朋友和得知的，Zset中存储有序的id字段，通过分页后拿到id，然后再用id去hash中
取，感觉应该效率相差不大的，只是中间多了层从hash结构取，还需要维护又一个hash；（为何这样做我也不清楚）；

链接：https://www.jianshu.com/p/9c89c579b7ef




结构 类型                	结构存储的值	结构的读写能力
String	可以是字符串、整数或者浮点数             	对整个字符串或者字符串的其中一部分执行操作；对象和浮点数执行自增(increment)
或者自减(decrement)
List	一个链表，链表上的每个节点都包含了一个字符串         	从链表的两端推入或者弹出元素；根据偏移量对链表进行修剪(trim)；
读取单个或者多个元素；根据值来查找或者移除元素
Set	包含字符串的无序收集器(unorderedcollection)，并且被包含的每个字符串都是独一无二的、各不相同	        添加、获取、移除单个元素；
检查一个元素是否存在于某个集合中；计算交集、并集、差集；从集合里卖弄随机获取元素
Hash	包含键值对的无序散列表                   添加、获取、移除单个键值对；获取所有键值对
