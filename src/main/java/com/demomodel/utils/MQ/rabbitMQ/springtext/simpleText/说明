​	工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。
相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。
当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。

​	这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。

​	接下来我们来模拟这个流程：

​ P：生产者：任务的发布者

​ C1：消费者，领取任务并且完成任务，假设完成速度较快

C2：消费者2：领取任务并完成任务，假设完成速度慢



但是刚才的实现有一个问题：
消费者1比消费者2的效率要低，一次任务的耗时较长
然而两人最终消费的消息数量是一样的
消费者2大量时间处于空闲状态，消费者1一直忙碌
现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。

​	我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向消费者发送多于一条消息。
 或者换句话说，不要向消费者发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工消费者。